<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<title>YALMIP Example : Logic programming</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta content="Microsoft FrontPage 6.0" name="GENERATOR">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link href="yalmip.css" type="text/css" rel="stylesheet">
<base target="_self">
</head>

<body leftMargin="0" topMargin="0">

<div align="left">
  <table border="0" cellpadding="4" cellspacing="3" style="border-collapse: collapse" bordercolor="#000000" width="100%" align="left" height="100%">
    <tr>
      <td width="100%" align="left" height="100%" valign="top">
                      <h2>Logic programming</h2>
      <hr noShade SIZE="1" color="#000000">
           <p>By using <a href="extoperators.htm">nonlinear operators</a>, 
			logic programming is easily added to YALMIP. The logic programming 
			module is not intended to be used for large logic programs, but is 
			only implemented to help the user to add a small number of logic 
			constraints to a standard model. Note that logic constraints leads 
			to a problem with binary variables, hence mixed integer programming 
			is needed to solve the problem. The logic functionality has not been 
			tested much, and was mainly implemented to 
			show the strength of <a href="extoperators.htm">nonlinear operators</a>. A lot of features are 
			still lacking, but are typically easy to add. If you need it, 
			make a feature request!</p>
                      <h3>Simple logic constraints</h3>
                      <p>As a first example, let us solve a simple 
                      satisfiability problem. Note the use of binary variables 
                      and the <b>TRUE</b> operator (the <b>true</b> operator 
                      takes a variable <b>x </b>and returns the constraint <b>
                      x&#8805;1</b>.)</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>binvar a b c d e f
F = set(true((a &amp; b &amp; c) | (d &amp; e &amp; f)));
solvesdp(F);
double([a b c d e f])
<font color="#000000">ans =
     0     0     0     1     1     1</font></pre>
               </td>
             </tr>
           </table>
                      <p>A constraint with a scalar logic expression, generated by 
                      the operators <b>AND</b> or <b>OR</b>, is automatically handled as a truth 
                      constrained variable (although it is strongly advised to 
                      use the truth operator.) Hence the following constraint is 
                      equivalent.</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>F = set((a &amp; b &amp; c) | (d &amp; e &amp; f));
solvesdp(F);
double([a b c d e f])
<font color="#000000">ans =
     0     0     0     1     1     1</font></pre>
               </td>
             </tr>
           </table>
           <p>A truth constraint on a standard variable must however be 
           explicitly stated</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>F = set((a &amp; b &amp; c) | (d &amp; e &amp; f)) + set(true(d));
solvesdp(F);
double([a b c d e f])
<font color="#000000">ans =
     0     0     0     1     1     1</font></pre>
               </td>
             </tr>
           </table>
                      <p>or equivalently</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>F = set((a &amp; b &amp; c) | (d &amp; e &amp; f)) + set(d &gt;= 1);
solvesdp(F);
double([a b c d e f])
<font color="#000000">ans =
     0     0     0     1     1     1</font></pre>
               </td>
             </tr>
           </table>
                      <p>To constrain an expression to be false, use the <b>
                      FALSE</b> operator,</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>F = set(false((a &amp; b &amp; c) | (d &amp; e &amp; f)));
solvesdp(F);
double([a b c d e f])
<font color="#000000">ans =
     1     0     0     1     0     0</font></pre>
               </td>
             </tr>
           </table>
           <p>or simply add the corresponding numerical constraint (Notice that 
			we use inequality instead of equality constraint. The reason is 
			rather technical but it is recommended, since the convexity 
			propagation algorithm used for expanding the
			<a href="extoperators.htm">nonlinear operators</a> might fail 
			otherwise)</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>F = set(((a &amp; b &amp; c) | (d &amp; e &amp; f)) &lt;= 0);
solvesdp(F);
double([a b c d e f])
<font color="#000000">ans =
     1     0     0     1     0     0</font></pre>
               </td>
             </tr>
           </table>
                      <p>Objective functions are allowed.</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>F = set(((a &amp; b &amp; c) | (d &amp; e &amp; f)) &lt;= 0);
solvesdp(F,-a-b-c-d-e-f);
double([a b c d e f])
<font color="#000000">ans =
     1     0     1    1     0     1</font></pre>
               </td>
             </tr>
           </table>
                      <p>In addition to the operators <b>AND</b> (&amp;), <b>OR</b> 
                      (|) and <b>NOT</b> (~), the operator <b>IMPLIES(X,Y)</b> 
                      is implemeted. To force <b>e</b> to be true if <b>f</b> is 
                      true, we use <b>IMPLIES</b>.</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>F = set(((a &amp; b &amp; c) | (d &amp; e &amp; f)) &lt;= 0) + set(implies(f,e));
solvesdp(F,-a-b-c-d-e-f);
double([a b c d e f])</pre>
               </td>
             </tr>
           </table>
                      <p>An equivalent formulation is</p>
           <table cellPadding="10" width="100%" id="table2">
             <tr>
               <td class="xmpcode">
               <pre>F = set(((a &amp; b &amp; c) | (d &amp; e &amp; f)) &lt;= 0) + set(e &gt;= f);
solvesdp(F,-a-b-c-d-e-f);
double([a b c d e f])</pre>
               </td>
             </tr>
           </table>
                      <h3>Mixed logic and conic constraints</h3>
						<p>The first construction for creating mixed constraints 
						is <b>IMPLIES</b>. The following trivial program ensures the 
						symmetric matrix <b>X</b> to have eigenvalues larger than 1 if
						<b>a</b> or <b>b</b> is true. The result is a mixed 
						integer semidefinite problem which will be solved using 
						YALMIPs mixed integer solver. Be warned, a lot of the 
						functionality here is experimental. Please validate your 
						results and report any oddities as usual.</p>
           <table cellPadding="10" width="100%" id="table1">
             <tr>
               <td class="xmpcode">
               <pre>binvar a b
X = sdpvar(3,3);
F = set(implies(a | b, X &gt; eye(3)));
solvesdp(F)</pre>
               </td>
             </tr>
           </table>
                      <p>The following construction ensures the variable <b>x</b> 
						to be contained in a polytope if <b>d</b> is true</p>
           <table cellPadding="10" width="100%" id="table3">
             <tr>
               <td class="xmpcode">
               <pre>A = randn(5,2);
b = rand(5,1);
x = sdpvar(2,1);
d = binvar(1,1);
F = set(implies(d,A*x &lt;=b))</pre>
               </td>
             </tr>
           </table>
                      <p>A related command is if-and-only-if, <b>IFF</b>, i.e. 
						logic equivalence. The following code force the 
						variable <b>x</b> to be contained in a polytope if <b>y</b> is 
						contained in the polytope, and vice versa.</p>
           <table cellPadding="10" width="100%" id="table4">
             <tr>
               <td class="xmpcode">
               <pre>A = randn(5,2);
b = rand(5,1);
x = sdpvar(2,1);
y = sdpvar(2,1);
F = set(iff(A*x &lt;= b, A*y &lt;= b))</pre>
               </td>
             </tr>
           </table>
                      <p>This functionality can be used to model various logic 
						constraints. Consider for instance the constraint that a 
						variable is in one of several polytopes.
						<img border="0" src="polytopes.jpg" width="809" height="472"></p>
						<p>The data and plot was generated with the following 
						code (assuming <a href="solvers.htm#mpt">MPT</a> is 
						installed)</p>
           <table cellPadding="10" width="100%" id="table5">
             <tr>
               <td class="xmpcode">
               <pre>A1 = randn(8,2);
b1 = rand(8,1)*2-A1*[3;3];
A2 = randn(8,2);
b2 = rand(8,1)*2-A2*[-3;3];
A3 = randn(8,2);
b3 = rand(8,1)*2-A3*[3;-3];
A4 = randn(8,2);
b4 = rand(8,1)*2-A4*[-3;-3];
plot(polytope(A1,b1),polytope(A2,b2),polytope(A3,b3),polytope(A4,b4))</pre>
               </td>
             </tr>
           </table>
                      <p>We will now try to find a point <b>x</b> as far up in 
						the figure as possible, but still in one of the 
						polytope. First, we define 4 binary 
						variables, each one describing whether we are in the 
						corresponding polytope, and add the constraint that we 
						are in at least one polytope.</p>
           <table cellPadding="10" width="100%" id="table6">
             <tr>
               <td class="xmpcode">
               <pre>binvar inp1 inp2 inp3 inp4
F = set(inp1 | inp2 | inp3 | inp4);</pre>
               </td>
             </tr>
           </table>
                      <p>To connect the binary variables with the polytopes, we 
						use the <b>IFF</b> operator.</p>
           <table cellPadding="10" width="100%" id="table7">
             <tr>
               <td class="xmpcode">
               <pre>x = sdpvar(2,1);</pre>
				<pre>F = F + set(iff(inp1,A1*x &lt; b1));
F = F + set(iff(inp2,A2*x &lt; b2));
F = F + set(iff(inp3,A3*x &lt; b3));
F = F + set(iff(inp4,A4*x &lt; b4));</pre>
               </td>
             </tr>
           </table>
                      <p>Finally, we solve the problem by maximizing the second 
						coordinate of x.</p>
           <table cellPadding="10" width="100%" id="table8">
             <tr>
               <td class="xmpcode">
               <pre>solvesdp(F,-x(2));

double(x)
<font color="#000000">ans =</font></pre>
				<pre><font color="#000000">    4.5949
    4.2701</font></pre>
				<pre>double([inp1 inp2 inp3 inp4])
<font color="#000000">ans =</font></pre>
				<pre><font color="#000000">     0     0     0     1</font></pre>
               </td>
             </tr>
           </table>
                      <p>The <b>IFF</b> is overloaded as equality, hence the 
						following code generates the same problem.</p>
           <table cellPadding="10" width="100%" id="table12">
             <tr>
               <td class="xmpcode">
               <pre>F = set(inp1 | inp2 | inp3 | inp4);
F = F + set(inp1 == (A1*x &lt; b1));
F = F + set(inp2 == (A2*x &lt; b2));
F = F + set(inp3 == (A3*x &lt; b3));
F = F + set(inp4 == (A4*x &lt; b4));
solvesdp(F,-x(2));</pre>
               </td>
             </tr>
           </table>
                      <p>We should mention that it is not necessary to 
						use the <b>IFF</b> operator in this problem, the <b>
						IMPLIES</b> operator suffice. The implies operator 
						should be used when possible, since it for most cases is 
						more efficiently implemented (less number of additional 
						binary variables) than the <b>IFF</b> function. As a 
						general comment, if you want to play it safe, stay away 
						from <b>IFF</b> as much as possible, and don't use <b>
						IMPLIES</b> with the first argument being anything else 
						than a binary variable. </p>
           <table cellPadding="10" width="100%" id="table10">
             <tr>
               <td class="xmpcode">
				<pre>F = set(inp1 | inp2 | inp3 | inp4);
F = F + set(implies(inp1,A1*x &lt; b1));
F = F + set(implies(inp2,A2*x &lt; b2));
F = F + set(implies(inp3,A3*x &lt; b3));
F = F + set(implies(inp4,A4*x &lt; b4));
solvesdp(F,-x(2));

double(x)
<font color="#000000">ans =</font></pre>
				<pre><font color="#000000">    4.5949
    4.2701</font></pre>
               </td>
             </tr>
           </table>
                      <p>The <b>IFF</b> operator is used internally to construct 
						mixed constraints involving <b>OR</b>. 
						With this functionality, we can solve the previous 
						problem using a more intuitive code (albeit 
						possibly inefficient since it will use <b>IFF</b> 
						instead of <b>IMPLIES</b>).</p>
           <table cellPadding="10" width="100%" id="table11">
             <tr>
               <td class="xmpcode">
				<pre>F = set( (A1*x &lt; b1) | (A2*x &lt; b2) | (A3*x &lt; b3) | (A4*x &lt; b4));
solvesdp(F,-x(2));

double(x)
<font color="#000000">ans =</font></pre>
				<pre><font color="#000000">    4.5949
    4.2701</font></pre>
               </td>
             </tr>
           </table>
                      <h3><a name="bounds"></a>Improving the Big-M formulation</h3>
                      <p>The conversion from logic constraints to mixed integer 
						constraints is done in YALMIP using a standard big-M 
						formulation. By default, YALMIP uses a big-M value of 
						10<sup>4</sup>, but it is recommended to add constraints 
						to improve this. By explicitly adding bounds on 
						variables, YALMIP can exploit these bounds to compute a 
						reasonably small big-M constant.</p>
           <table cellPadding="10" width="100%" id="table13">
             <tr>
               <td class="xmpcode">
				<pre>x = sdpvar(2,1);
F = set( (A1*x &lt; b1) | (A2*x &lt; b2) | (A3*x &lt; b3) | (A4*x &lt; b4));
F = F + set(-100 &lt; x &lt; 100);
solvesdp(F,-x(2));

double(x)
<font color="#000000">ans =</font></pre>
				<pre><font color="#000000">    4.5949
    4.2701</font></pre>
               </td>
             </tr>
           </table>
                      <p>Adding bounds can significantly improve the strength of 
						the relaxations and corresponding reduction of 
						computation time. Hence, if you know, or can estimate, 
						lower and upper bounds, let YALMIP know this. If you 
						fail to add bounds, YALMIP will issue warnings.</p>
                      <h3><a name="sudoku"></a>Sudoku example</h3>
                      <p>There are not many logic constructions implemented at 
						the moment, but 
						they can easily be added if you make a request. As an 
						example, the logic constraint <b>ALLDIFFERENT</b> was 
						easily implemented as a nonlinear operator. Let us use 
						the operator to solve a Sudoku game.</p>
           <table cellPadding="10" width="100%" id="table15">
             <tr>
               <td class="xmpcode">
				<pre>S = [0,0,1,9,0,0,0,0,8;6,0,0,0,8,5,0,3,0;0,0,7,0,6,0,1,0,0;...
     0,3,4,0,9,0,0,0,0;0,0,0,5,0,4,0,0,0;0,0,0,0,1,0,4,2,0;...
     0,0,5,0,7,0,9,0,0;0,1,0,8,4,0,0,0,7;7,0,0,0,0,9,2,0,0];</pre>
				<pre>ans =</pre>
				<pre>0  0  1  9  0  0  0  0  8
6  0  0  0  8  5  0  3  0
0  0  7  0  6  0  1  0  0
0  3  4  0  9  0  0  0  0
0  0  0  5  0  4  0  0  0
0  0  0  0  1  0  4  2  0
0  0  5  0  7  0  9  0  0
0  1  0  8  4  0  0  0  7
7  0  0  0  0  9  2  0  0</pre>
               </td>
             </tr>
           </table>
                      <p>In case you have missed out on the Sudoko hype, the 
						goal is to replace the zeros with numbers between 1 to 
						9, keeping elements in all rows and columns different, 
						and keeping all elements in the 9 3x3 blocks different.</p>
						<p>Let us create our 9x9 integer decision variable and define 
						the basic constraints</p>
           <table cellPadding="10" width="100%" id="table16">
             <tr>
               <td class="xmpcode">
				<pre>M = intvar(9,9,'full');

fixed = find(S);
F = set(1 &lt;= M &lt;= 9) + set(M(fixed) == S(fixed));</pre>
               </td>
             </tr>
           </table>
                      <p>We add the logic constraints using some MATLAB indexing 
						tricks, add some redundant cuts, and solve the problem (The 
						solution time 
						depends highly on your MILP solver.
						<a href="solvers.htm#cplex">CPLEX</a> solves 
						this problem in roughly 0.1 seconds, while
						<a href="solvers.htm#glpk">GLPK</a> fails.)</p>
           <table cellPadding="10" width="100%" id="table17">
             <tr>
               <td class="xmpcode">
				<pre>for i = 1:3
    for j = 1:3
        block = M(find(kron(full(sparse(i,j,1,3,3)),ones(3))));
        F = F + set(alldifferent(block));
    end
end

for i = 1:9
    F = F + set(alldifferent(M(i,:)));
    F = F + set(alldifferent(M(:,i)));
end

F = F + set(sum(M,1) == 45) + set(sum(M,2) == 45);</pre>
				<pre>solvesdp(F);</pre>
               </td>
             </tr>
           </table>
						<p>Note that this model of the Sudoku game is pretty 
						weak. A much better model can be obtained by using a 
						scheme based on having a binary for each possible value 
						for each element. This is left as an exercise.</p>
						<h3><a name="index"></a>Variable index variables</h3>
						<p>By combining the framework for
                      <a href="extoperators.htm">nonlinear operators</a> and 
						logic programming, YALMIP allows variable indices. The 
						following silly example picks out the two highest 
						indices of elements in a vector <b>p</b> smaller than or 
						equal to three.</p>
           <table cellPadding="10" width="100%" id="table14">
             <tr>
               <td class="xmpcode">
               <pre>sdpvar i j
x = sdpvar(1,8);
p = [0 1 7 2 3 4 3 20];
solvesdp(set(x == p)+set(x([i j]) &lt;= 3)+set(i~=j),-i-j);
double([i j])
<font color="#000000">ans =</font></pre>
				<pre><font color="#000000">     5     7</font></pre>
               </td>
             </tr>
           </table>
                      <h3>Behind the scenes</h3>
                      <p>The logic <b>AND</b> and <b>OR</b> operators are implemented using
                      <a href="extoperators.htm">nonlinear operators</a>. As an 
                      example, to implement the <b>OR</b> 
                      operator <b>z=or(x,y)</b> for binary <b>x</b> and <b>y</b>, the simple code below is 
                      sufficient (the code actually used is slightly different 
						to improve performance for expressions with more than 
						two variables, 
						but the idea is the same). The first constraint ensures that <b>z</b> is 
                      false if both <b>x</b> and <b>y</b> are false, the two 
                      following constraints ensure that <b>z</b> is true if <b>x</b> 
                      or <b>y</b> is true, while the last constraint constrains 
                      <b>z</b> to be a binary (true/false) variable.</p>
           <table cellPadding="10" width="100%">
             <tr>
               <td class="xmpcode">
               <pre>function varargout = or(varargin)
% SDPVAR/OR

switch class(varargin{1})
    case 'char'
        z = varargin{2};
        x = varargin{3};
        y = varargin{4};
        
        varargout{1} = set(x + y &gt;= z) + set(z &gt;= x) + set(z &gt;= y) + set(binary(z));
        varargout{2} = struct('convexity','milp','monotonicity','milp','definiteness','milp');
        varargout{3} = [x y];</pre>
               <pre>    case 'sdpvar'
        x = varargin{1};
        y = varargin{2};
        varargout{1} = yalmip('addextendedvariable','or',varargin{:});</pre>
               <pre>    otherwise
end</pre>
               </td>
             </tr>
           </table>
                      <p>The operators <b>IFF</b> and <b>IMPLIES</b> are just 
						standard implementations of big-M reformulations, 
						implemented in the
                      <a href="extoperators.htm">nonlinear operators</a> 
						framework.</td>
    </tr>
  </table>
</div>

</body>

</html>